{"version":3,"sources":["lib/prompts.js","lib/output.js","lib/fetcher.js","lib/helper.js","lib/error_handler.js","lib/listener.js","lib/matchObs.js","index.js"],"names":["inquirer","require","module","exports","askTypeOfMatch","prompt","type","name","message","choices","filter","val","then","answers","matchType","catch","err","askForMatch","options","match","chalk","figlet","boxen","logUpdate","getTitle","text","green","bold","makeDashedLine","repeat","printName","console","log","yellow","magentaBright","textSync","font","horizontalLayout","verticalLayout","showStats","stats","score","crr","status","venue","toss","msg","grey","cyanBright","team1","team2","series","batting","winner","decision","location","padding","margin","borderStyle","dimBorder","borderColor","throwError","errText","red","process","exit","throwNoMatchesError","axios","getLiveMatches","liveMatches","response","get","error","data","matches","forEach","element","currTime","Date","getTime","header","state","end_time","push","getMatchStats","resp","match_id","CLUI","Spinner","makeChoicesFromMatches","choice","s_name","series_name","getMatches","srs_category","includes","makeSpinner","spinner","handler","promise","undefined","Promise","resolve","fetcher","Observable","delay","lastUpdated","listener","observer","statsErr","last_update_time","next","complete","initListener","output","dns","prompts","helper","matchObs","typeErr","lookup","spinnerFirst","start","liveMatchesErr","length","stop","matchErr","ID","indexOf"],"mappings":"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","file":"index.js","sourceRoot":"..","sourcesContent":["const inquirer = require('inquirer')\n\nmodule.exports = {\n\taskTypeOfMatch: () => {\n\t\treturn inquirer.prompt({\n\t\t\ttype: 'list',\n\t\t\tname: 'matchType',\n\t\t\tmessage: 'Select the type of match you want to know the live stats about:',\n\t\t\tchoices: [\"All üëÄ\", \"International üåé\", \"Domestic üè†\"],\n\t\t\tfilter: function(val) {\n\t\t\t\treturn (val == \"International üåé\") ? 1 : (val == \"Domestic üè†\") ? 3 : 0;\n\t\t\t}\n\t\t})\n\t\t.then(answers => {\n\t\t\treturn answers.matchType;\n\t\t}).catch(err => {throw err})\n\t},\n\n\taskForMatch: (options) => {\n\t\treturn inquirer.prompt({\n\t\t\ttype: 'list',\n\t\t\tname: 'match',\n\t\t\tmessage: 'Select a match:',\n\t\t\tchoices: options\n\t\t})\n\t\t.then(answers => {\n\t\t\treturn answers.match;\n\t\t}).catch(err => {throw err})\n\t}\n}\n","const chalk = require('chalk'),\n\t  figlet = require('figlet'),\n\t  boxen = require('boxen'),\n\t  logUpdate = require('log-update'),\n\t  getTitle = (text) => {return chalk.green.bold(text)},\n\t  makeDashedLine = () => {return chalk.green.bold(\"~\".repeat(80))};\n\n\nmodule.exports = {\n\tprintName: () => {\n\t\tconsole.log(\n\t\t\tchalk.yellow.magentaBright(\n\t\t\t\tfiglet.textSync('CricFeed', { font: 'Merlin1', horizontalLayout: 'fitted', verticalLayout: 'fitted' })\n\t\t\t)\n\t\t)\n\t},\n\n\tshowStats: (stats) => {\n\t\tconst score = getTitle('Score: ');\n\t\tconst crr = getTitle('CRR: ');\n\t\tconst status = getTitle('Status: ');\n\t\tconst venue = getTitle('Venue: ');\n\t\tconst toss = getTitle('Toss: ');\n\t\tconst typeOfMatch = chalk.grey.bold(`[${stats.type}]`);\n\t\tconst title = chalk.cyanBright.bold(`${stats.team1.name} vs. ${stats.team2.name} [${stats.series.name}]`);\n\t\tconst msg = `${typeOfMatch} ${title}\\n\\\n${makeDashedLine()}\\n ${status} ${stats.status}\\n ${score} ${stats.score.batting.score}\\n \\\n${crr} ${stats.score.crr}\\n ${toss} ${stats.toss.winner} chose ${stats.toss.decision}\\n ${venue} ${stats.venue.name}, ${stats.venue.location}`;\n\n\t\tlogUpdate(\n\t\t\tboxen(msg, {padding: 1, margin: 1, borderStyle: 'classic', dimBorder: true, borderColor: 'yellowBright'})\n\t\t);\n\t},\n\n\tthrowError: (errText) => {\n\t\tconsole.log(chalk.red.bold(errText));\n\t\tprocess.exit(1);\n\t},\n\n\tthrowNoMatchesError: (type) => {\n\t\tlet matchType = (type == 1) ? \"International \" : (type == 3) ? \"Domestic \" : \"\";\n\t\tconsole.log(chalk.red.bold(`No ${matchType}matches are live! üòê`));\n\t\tprocess.exit(1);\n\t}\n}\n","const axios = require('axios')\n\nmodule.exports = {\n\tgetLiveMatches: async () => {\n\t\tlet liveMatches = [];\n\t\tlet response = await axios.get('http://mapps.cricbuzz.com/cbzios/match/livematches')\n\t\tif(response.error) throw response.error;\n\t\tresponse = response.data.matches;\n\n\t\tresponse.forEach(element => {\n\t\t\tlet currTime = (new Date).getTime()/1000;\n\t\t\tif(element.header.state != \"preview\" && element.header.end_time > currTime) {\n\t\t\t\tliveMatches.push(element);\n\t\t\t}\n\t\t})\n\t\treturn liveMatches;\n\t},\n\n\tgetMatchStats: async (match_id) => {\n\t\tconst resp = await axios.get(`https://www.cricbuzz.com/match-api/${match_id}/commentary.json`)\n\t\tif(resp.error) throw resp.error;\n\t\treturn resp;\n\t}\n}\n","const CLUI = require('clui'),\n\t  Spinner = CLUI.Spinner;\n\nmodule.exports = {\n\tmakeChoicesFromMatches: (matches) => {\n\t\tlet choices = [];\n\t\tmatches.forEach(match => {\n\t\t\tlet choice = match.team1.name + \"( \" + match.team1.s_name + \" ) vs. \" + match.team2.name + \"( \" + match.team2.s_name + \" )\";\n\t\t\tchoice += \" [ \" + match.series_name + \" ]\";\n\t\t\tchoices.push(choice);\n\t\t})\n\t\treturn choices;\n\t},\n\n\tgetMatches: (liveMatches, type) => {\n\t\tlet matches = [];\n\t\tliveMatches.forEach(element => {\n\t\t\tif(element.srs_category.includes(type)) matches.push(element);\n\t\t})\n\t\treturn matches;\n\t},\n\n\tmakeSpinner: (type) => {\n\t\tlet spinner;\n\t\tif(type == 1) spinner = new Spinner(\"Fetching live international matches for you...\");\n\t\telse if(type == 3) spinner = new Spinner(\"Fetching live domestic matches for you...\");\n\t\telse spinner = new Spinner (\"Fetching live matches for you...\");\n\t\treturn spinner;\n\t}\n}\n","module.exports = {\n\thandler: (promise) => {\n\t\treturn promise\n\t\t.then(data => ([data, undefined]))\n\t\t.catch(err => Promise.resolve([undefined, err]))\n\t}\n}\n","const fetcher = require('./fetcher'),\n\t  Observable = require('zen-observable'),\n\t  delay = require('delay'),\n\t  {handler} = require('./error_handler');\n\nlet lastUpdated = null;\n\nasync function listener(match_id, observer) {\n\twhile (true) {\n\t\tlet [stats, statsErr] = await handler(fetcher.getMatchStats(match_id));\n\t\tif(statsErr) observer.error(statsErr);\n\t\tstats = stats.data;\n\n\t\tif(lastUpdated != stats.last_update_time/1000) {\n\t\t\tobserver.next(stats);\n\t\t}\n\n\t\tif(stats.series.end_time <= ((new Date).getTime())/1000) {\n\t\t\tobserver.complete();\n\t\t\treturn;\n\t\t}\n\n\t\tlastUpdated = stats.last_update_time/1000;\n\t\tawait delay(5000);\n\t}\n}\n\nmodule.exports = match_id => (\n\tnew Observable(observer => {\n\t\t(async () => {\n\t\t\tawait listener(match_id, observer);\n\t\t})().catch(err => {throw err})\n\t})\n);\n","const initListener = require('./listener'),\n\t  output = require('./output');\n\nmodule.exports = match_id => (async () => {\n\tawait initListener(match_id).forEach(data => {\n\t\toutput.showStats(data);\n\t})\n\t.catch(err => output.throwError(\"Something went wrong üòû\"))\n\n\t// Todo: HANDLE OBSERVER.COMPLETE()\n})();\n","const dns = require('dns');\nconst prompts = require('./lib/prompts');\nconst output = require('./lib/output');\nconst fetcher = require('./lib/fetcher');\nconst helper = require('./lib/helper');\nconst matchObs = require('./lib/matchObs');\nconst {handler} = require('./lib/error_handler');\n\n(async () => {\n    output.printName(); // Prints \"cricfeed\"\n\n    // Prompts user for type of matches\n    const [type, typeErr] = await handler(prompts.askTypeOfMatch());\n    if (typeErr)\n        output.throwError('Type of match not received, please select one!');\n\n    // Check user's internet connection and throw error if offline\n    dns.lookup('google.com', err => {\n        if (err) output.throwError('No internet connection! ‚ùå');\n    });\n\n    // Loading spinner starts\n    const spinnerFirst = helper.makeSpinner(type);\n    spinnerFirst.start();\n\n    // Fetches relevant live matches\n    const [liveMatches, liveMatchesErr] = await handler(\n        fetcher.getLiveMatches(),\n    );\n    if (liveMatchesErr)\n        output.throwError('Could not fetch live matches, please try again!');\n\n    // Filter out matches according to the user's query\n    let matches = helper.getMatches(liveMatches, type);\n    if (matches.length == 0) {\n        spinnerFirst.stop(); // Stop the spinner\n        output.throwNoMatchesError(type);\n    }\n\n    // Create a list of choices that user needs to select from\n    const choices = helper.makeChoicesFromMatches(matches);\n\n    spinnerFirst.stop(); // Stop the spinner\n\n    // Prompt the user to select a match from the list of choices\n    const [match, matchErr] = await handler(prompts.askForMatch(choices));\n    if (matchErr)\n        output.throwError(\n            'Could not fetch data for the match, please try again!',\n        );\n\n    // TODO: ADD SPINNER HERE (THINK ABOUT EXPORTING THE SPINNER OBJECT)\n\n    const ID = matches[choices.indexOf(match)].match_id; // ID of the match user selected\n    matchObs(ID); // Create an observable that keeps track of the stats for the desired match and shows them to the user\n})();\n"]}